#!/usr/bin/env ruby
require 'bundler/setup'
require 'yaml'
require 'oj'
require 'contracts'
require 'exponential_backoff'
require 'ezmq'
require 'robot_sweatshop/config'
$stdout.sync = true
include Contracts

Contract Or[String, nil], Hash => Bool
def whitelisted?(branch, in_config:)
  return true if in_config[:branch_whitelist].nil?
  in_config[:branch_whitelist].include? branch
end

Contract Hash => Hash
def sanitize(data)
  data = data.map { |key, value| {key => value.to_s} }
  data.reduce(:merge)
end

Contract Hash, Hash => Hash
def job_context(job_environment, context_from_payload)
  sanitize job_environment.merge(context_from_payload)
end

Contract String => Or[Hash, nil]
def load_if_exists(config)
  puts "Reading job configuration from #{config}"
  YAML.load_file config if File.exists? config
end

Contract String => Hash
def load_config_for(job_name)
  load_if_exists("#{job_path}/#{job_name}.yaml") || empty_config
end

Contract None => String
def job_path
  File.expand_path configatron.job_path
end

Contract None => Hash
def empty_config
  puts "Job configuration not found or empty"
  {}
end

Contract Hash => [Hash, String]
def parse_payload(request)
  client_settings = {
    port: configatron.payload_parser_port,
    encode: -> message { Oj.dump message },
    decode: -> message { Oj.load message }
  }
  client = EZMQ::Client.new client_settings
  request_hash = {
    payload: request[:payload],
    user_agent: request[:user_agent]
  }
  response = client.request(request_hash, {})
  puts response[:error] unless response[:error].empty?
  [response[:payload], response[:error]]
end

Contract Hash, Hash => Bool
def can_work_with?(job_config, payload)
  return false if job_config.empty?
  return false unless whitelisted? payload[:branch], in_config: job_config
  true
end

Contract Hash => Hash
def assemble(raw_job)
  job_config = load_config_for raw_job[:job_name]
  payload, error = parse_payload raw_job
  return {} unless error.empty? && can_work_with?(job_config, payload)
  {
    commands: job_config['commands'],
    context: job_context(job_config['environment'] || {}, payload),
    job_name: raw_job[:job_name],
    job_id: raw_job[:job_id]
  }
end

puts 'Started'
# TODO: profiler to get a better idea of how long we should wait based on historical information
conveyor_settings = {
  port: configatron.conveyor_port,
  encode: -> message { Oj.dump message },
  decode: -> message { Oj.load message }
}
conveyor = EZMQ::Client.new conveyor_settings
worker_settings = {
  port: configatron.worker_port,
  encode: -> message { Oj.dump message },
  decode: -> message { Oj.load message }
}
worker = EZMQ::Pusher.new worker_settings

backoff = ExponentialBackoff.new 0.1, 3
backoff.intervals.each do |interval|
  print '.'
  sleep interval
  job_id = conveyor.request({method: 'dequeue'}, {})
  next if job_id.nil?
  backoff.clear
  raw_job = conveyor.request({method: 'lookup', data: job_id}, {})
  puts "Assembling: '#{raw_job}'"
  raw_job.merge! job_id: job_id
  assembled_job = assemble raw_job
  worker.send(assembled_job, {}) unless assembled_job.empty?
end

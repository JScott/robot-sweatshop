#!/usr/bin/env ruby
require 'bundler/setup'
require 'oj'
require 'ezmq'
require 'contracts'
require 'robot_sweatshop/config'
require 'robot_sweatshop/payload'

$stdout.sync = true
include Contracts

Contract String => Bool
def json?(string)
  begin
    Oj.load string
    true
  rescue Oj::ParseError => e
    false
  end
end

Contract String => Bool
def from_github?(user_agent)
  user_agent.start_with? 'Github-Hookshot'
end

Contract String => Bool
def from_bitbucket?(user_agent)
  user_agent.start_with? 'Bitbucket.org'
end

Contract Hash => String
def detect_format_of(request)
  return 'empty' if request[:payload].empty?
  return 'Github' if from_github? request[:user_agent]
  return 'Bitbucket' if from_bitbucket? request[:user_agent]
  return 'JSON' if json? request[:payload]
  'unsupported'
end

Contract String, String => Or[Hash, nil]
def payload_hash_from(payload, format)
  begin
    Object.const_get("#{format}Payload").new(payload).to_hash
  rescue NameError
    nil
  end
end

Contract String, String => Hash
def parse(raw_payload, format)
  return {payload: {}, error: ''} if format == 'empty'
  return {payload: {}, error: 'Unknown format'} if format == 'unsupported'
  payload = payload_hash_from raw_payload, format
  return {payload: {}, error: "Invalid #{format} payload"} if payload.nil?
  {payload: payload, error: ''}
end

puts 'Started'
server_settings = {
  port: configatron.payload_parser_port,
  encode: -> message { message },
  decode: -> message { Oj.load message }
}
server = EZMQ::Server.new server_settings
server.listen do |request|
  puts "Parsing: #{request}"
  format = detect_format_of request
  Oj.dump parse(request[:payload], format)
end

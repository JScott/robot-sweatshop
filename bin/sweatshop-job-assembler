#!/usr/bin/env ruby
require 'bundler/setup'
require 'yaml'
require 'json'
require 'contracts'
require 'sweatshop/queue-helper'
require 'sweatshop/config'

$stdout.sync = true
include Contracts

Contract None => Hash
def empty_config
  puts "Job configuration not found"
  {}
end  

Contract String => Or[Hash, nil]
def load_if_exists(config)
  puts "Reading job configuration from #{config}"
  YAML.load_file config if File.exists? config
end

Contract None => String
def job_directory
  File.expand_path configatron.job_directory
end

Contract String => Hash
def load_config_for(job_name)
  load_if_exists("#{job_directory}/#{job_name}.yaml") || empty_config
end

Contract String => Hash
def parse_payload(payload)
  client = EZMQ::Client.new port: configatron.payload_parser_port
  payload = client.request payload
  puts "Payload Parser could not parse the given payload" if payload.empty?
  JSON.load(payload) || {}
end

Contract Or[String, nil], Hash => Bool
def whitelisted?(branch, in_config:)
  return true if in_config['branch_whitelist'].nil?
  in_config['branch_whitelist'].include? branch
end

Contract Hash, Hash => Bool
def can_work_with?(job_config, payload)
  # TODO: payload.empty? isn't expressive
  # have the payload parser return errors in a more explicit format
  # {"error": "broken", "payload": ...}
  return false if job_config.empty? || payload.empty?
  return false unless whitelisted? payload['branch'], in_config: job_config
  true
end

Contract Hash => Hash
def convert_arrays_and_hashes_in(data)
  data.each_pair do |key, value|
    data[key] = value.to_json if value.is_a?(Array) || value.is_a?(Hash)
  end
  # Hash[data.map { |key, value| [key.to_sym, value.to_json] }]
  # data.each_pair { |key, value| {key, value.to_json} }
end

Contract Hash, Hash => Hash
def job_context(job_environment, context_from_payload)
  context = job_environment.merge context_from_payload
  convert_arrays_and_hashes_in context
end

Contract Hash => Or[Hash, false]
def assemble_job(request)
  job_config = load_config_for request['job_name']
  payload = parse_payload request['payload']
  return false unless can_work_with? job_config, payload
  {
    commands: job_config['commands'],
    context: job_context(job_config['environment'], payload),
    job_name: request['job_name']
  }
end

puts 'Started'
QueueHelper.wait_for('payload') do |request|
  puts "Assembling: #{request}"
  assembled_job = assemble_job request
  QueueHelper.enqueue assembled_job, to: 'jobs' if assembled_job
end

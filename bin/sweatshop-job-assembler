#!/usr/bin/env ruby
require 'bundler/setup'
require 'yaml'
require 'contracts'
require 'sweatshop/queue-helper'
require 'sweatshop/config'

$stdout.sync = true
include Contracts

Contract Hash => Or[Hash, nil]
def load_config(for_job:)
  job_directory = File.expand_path configatron.job_directory
  file_path = "#{job_directory}/#{for_job}.yaml"
  puts "Reading job config from #{file_path}"
  if File.file?(file_path)
    YAML.load_file file_path
  else
    puts "No config found for job '#{for_job}'"
    nil
  end
end

Contract Any => String
def serialize(value)
  value.is_a?(Hash) ? JSON.dump(value) : value.to_s
end

Contract String => Or[Hash, nil]
def parse_payload(payload)
  client = EZMQ::Client.new port: configatron.payload_parser_port
  payload = client.request payload
  puts "Payload Parser could not parse the given payload" if payload.empty?
  JSON.load payload
end

Contract Or[String, nil], Hash => Bool
def whitelisted?(branch, in_config:)
  return true if in_config['branch_whitelist'].nil?
  in_config['branch_whitelist'].include? branch
end

Contract Hash => Or[Hash, nil]
def assemble_job(request)
  job_config = load_config for_job: request['job_name']
  payload = parse_payload request['payload']
  return nil if job_config.nil? || payload.nil?
  return nil unless whitelisted? payload['branch'], in_config: job_config
  context = job_config['environment'].merge payload
  context.each { |key, value| context[key] = serialize value }
  {
    commands: job_config['commands'],
    context: context,
    job_name: request['job_name']
  }
end

puts 'Started'
QueueHelper.wait_for('payload') do |request|
  puts "Assembling: #{request}"
  assembled_job = assemble_job request
  QueueHelper.enqueue assembled_job, to: 'jobs' if assembled_job
end
